# Software Architecture

![SoftArchitecture](https://github.com/kksjae-hyyejji/Moic-Backend-Refactoring/assets/87571953/a5af2e3b-935b-4c1c-a02c-cf6f3572d50f)

## 클린 아키텍처 적용 이유

- 계층 간의 모든 의존성을 안쪽으로 향하게 하여 변경 가능성을 줄입니다.
    - 상위 계층의 변화가 하위 계층에 변화를 주지 않도록 합니다.

![Package](https://github.com/kksjae-hyyejji/Moic-Backend-Refactoring/assets/87571953/d14c6a5a-075e-4642-91e7-21ada4a3d2b0)

- **`‘소리 치는 아키텍처’`**로 패키지, 클래스의 이름만으로 무엇을 하는지 대략적으로라도 유추하게 하고 싶었습니다.
    - 도메인을 기준으로 adapter, application, domain으로 나뉩니다.
        - adapter는 in과 out으로 나뉩니다.
            - 요청을 받는 in 에는 Controller
            - out에는 external(외부 서비스), persistence(영속성)의 구현체가 위치합니다.
        - application도 port에 in과 out으로 나뉩니다.
            - in에는 컨트롤러가 사용할 UseCase의 interface가 위치합니다.
            - out에는 external(외부 서비스), persistence 계층 으로 향하는 port가 위치합니다.
            - application은 바깥 계층으로 향하는 것에 대해 port만 알고 있습니다.
        - domain
- application 계층으로 진입하는 길은 **port**로 이용합니다.
    - 의존성을 역전시켜 도메인 코드가 바깥쪽 코드로 의존하지 않도록 합니다.

## 적용하면서 고민했던 점

- **adapater 계층과 application 계층의 Request 변환을 하지 않습니다.**
    - 토론 결과 Dto가 같은 형태일 경우 변화가 필요하지 않다고 판단했습니다.
    - Dto가 서로 다른 형태를 가져야 하는 경우는, 컨트롤러와 서비스가 이용하는 Dto의 모습이 다를 때입니다. 아직 이러한 경우를 마주하지 못했습니다.
        - **다른 형태를 필요로 한다면,** **그 때 분리를 하는 것으로 결론지었습니다.**
- **CQRS 패턴을 적용합니다.**
    - 프로젝트에서 JPA와 Querydsl을 동시에 사용하고 있습니다.
        - 처음에는 JPA와 Querydsl을 구분지으려 했으나, 경계가 명확하지 않았습니다.
    - 하여 DB의 변화를 요구하는 Command와, 단순 조회를 요구하는 Query를 분리합니다.
    - Command, Query 어느 부분에서 문제가 발생했는지에 따라 가독성이 높아집니다.
        - JPA와 Querydsl의 경계는 명확하지 않으나, Command와 Query의 경계가 명확해짐에 따라 추후 유지보수의 가능성을 더 높게 판단했습니다.
- **헬퍼 클래스(util)의 크기를 어떻게 명확하게 할 것인가?**
    - 범위가 애매한 것에 대해 자꾸 util 클래스로 집어넣으려는 유혹이 발생했습니다. 결국, 걷잡을 수 없이 util의 클래스가 커져버립니다.
    - 해당 위치에는 global하게만 사용되는 것만 들어가도록 합니다.
        - 데이터베이스 설정 정보, BaseEntity, 응답 포맷(Response), Exception
        

## 아키텍처를 적용하면서 느낀 점

- 아키텍처는 만병통치약이 아니다. 팀 간 적절한 규칙을 정하고 해당 규칙을 고수한다면, 그것 또한 방법이 될 수 있다고 생각한다.
- 패키지에 무엇이 위치해야 하고, 클래스가 어떤 역할을 하는지 생각하면서 코드를 작성하게 된다. 굳이 클린 아키텍처가 아니더라도, 이런 의미에서 강제성이 부여가 되어 유지보수에 도움이 된다.
- 직접 구현했던 프로젝트였음에도 불구하고, 구조와 코드를 수정하는 작업이 쉽지만은 않았습니다. 하나의 클래스에 의존성으로 엮여 있는 것들이 많았기 때문입니다. 리팩토링을 진행하며 프로젝트의 시작부터 객체지향적인 프로그래밍과 클린 아키텍처를 적용하는 것이 중요함을 배웠습니다.
결국 모든 프로젝트는 서비스를 운영하며 유지보수의 작업을 거치게 되기 마련인데, 이를 위해 유지보수성을 생각하는 프로그래밍을 하고자 다짐하게 되었습니다.
- 확장성을 고려하게 되었습니다. 여러 가지 서비스를 운영하다 보면, 각각의 서비스는 다른 서비스의 세부 내용을 알지 못합니다.
알지 못하는 상황에서도 서비스 구현 및 제공을 하기 위해서는 각각의 포트가 그 역할을 해주어야 함을 배울 수 있는 시간이었습니다.
